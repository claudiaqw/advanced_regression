---
title: "Estimación de la mortalidad de la COVID-19"
author: "Claudia Quintana Wong"
date: "26/2/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
library(dplyr)
library(tidyverse)
library(lubridate)
library(funModeling)
library(ggplot2)
library(GGally)
library(caret)
library(effects)
```


## Introducción

Los modelos lineales generalizados son un extensión de los modelos de regresión lineal que se utilizan cuando la distribución de la variable dependiente no es normal.


## Desarrollo

En esta sección ...

### Descripción del *dataset*

Los datos fueron tomados de 

https://github.com/CSSEGISandData/COVID-19/tree/master/csse_covid_19_data/csse_covid_19_daily_reports_us.

Las variables originales son:

* Province_State: El nombre del estado dentro de Estados Unidos
* Country_Region: El nombre del país. En todos los casos toma valor US.
* Last_Update: La fecha más reciente en que el fichero fue actualizado.
* Lat
* Long_
* Confirmed: Cantidad de casos confirmados agregados para el estado
* Deaths: Cantidad de muertes agregadas para el estado
* Recovered: Cantidad de casos recuperados para el estado
* Active: cantidad de casos ativos que no han sido resueltos (Active cases = total cases - total recovered - total deaths)
* FIPS: Federal Information Processing Standards. código que identifica a los condados en US.
* Incident_Rate: casos por 100 000 habitantes
* Total_Test_Results: Cantidad total de personas que se han hecho tests
* People_Hospitalized: Cantidad de personas hospitalizadas (se dejó de tomar el 31 Agosto)
* Case_Fatality_Ratio: Cantidad de muertes * 100/Cantidad de Casos confirmados
* UID: identificador de fila
* ISO3: identificador oficial de país
* Testing_Rate: Cantidad de tests por 100.000 habitantes.  Total test results = Total test results(Positive + Negative)
* Hospitalization_Rate: Cantidad de Hospitalizados / cantidad de casos. 


### Carga y transformación

```{r}
data <- read.csv(file = 'data/covid_data_us.csv')
```

Transformamos los campos de tipo date

```{r}
data$Last_Update <- as.Date(data$Last_Update)
data$Date <- as.Date(data$Date)

summary(data)
```
```{r}
colSums(is.na(data))
```
En el dataset existen muchas filas que tienen valores Nan en alguna de las variables. En el caso de las variables **People_Hospitalized** y **Hospitalization_Rate**, cerca de un 70% de los datos son descinocidos. Por esta razón no podemos eliminarlas. Por lo tanto, se recurre a la imputación de valores. Para la imputacióm se toma la media de los valores que ha tomado esa variable en ese mes y año en ese estado específico. Mediante la aplicación de este método se reduce el ruido introducido por los métodos tradicionales de imputar con zeros o con algunos de los estadísticos de forma.

```{r}
ampute <- function(df, index, state, date){
  new.df <- df %>% 
    filter(Province_State == state, month(Date) == month(date), year(Date) == year(date))
  value <- mean(new.df[,index], na.rm = TRUE)
  return(value)
}

data$Recovered[is.na(data$Recovered)] = 
  ampute(data, 8, data$Province_State, data$Date)

data$People_Hospitalized[is.na(data$People_Hospitalized)] =
  ampute(data, 13, data$Province_State, data$Date)

data$Hospitalization_Rate[is.na(data$Hospitalization_Rate)] =
  ampute(data, 18, data$Province_State, data$Date)

```

Tras aplicar el reemplazo de los valores desconocidos, se puede observar que el conjunto de datos queda libre de *missing values*.

```{r}
colSums(is.na(data))
```
Se toman los datos a prtir del 1ro de julio de 2020 puesto que los datos son más fiables.

```{r}

covid.data <- data %>% 
  select(Province_State, Confirmed, Deaths, Recovered, Active, Incident_Rate, Total_Test_Results, People_Hospitalized, Case_Fatality_Ratio, Testing_Rate, Hospitalization_Rate, Date) %>% 
  filter(data$Date >= "2020-07-01") %>% 
  arrange(Date)
  
```

### Análisis descriptivo


```{r}
plot_num(covid.data)
```

```{r}
numeric_cols = sapply(covid.data, is.numeric)

boxplot(scale(covid.data[, numeric_cols]), las=2, col='darkblue')
```
```{r}
covid.data %>% 
  ggplot(aes(x=Confirmed, y=Deaths)) +
  geom_point()
```

```{r}
covid.data %>% 
  ggplot(aes(x=Date, y=Confirmed)) + 
  geom_line(color='#00AFBB', size = 2)

```
```{r}

covid.data %>% 
  ggplot(aes(x=Date, y=Deaths)) + 
  geom_line(color='#00AFBB', size = 1)

```
### Modelo de regresión

Según la OMS: "Una importante característica de las enfermedades infecciosas es la gravedad, que en última instancia se mide por su capacidad para causar la muerte. Las tasas de letalidad ayudan a entender la gravedad de la enfermedad, a identificar las poblaciones en riesgo y a evaluar la calidad de la atención sanitaria". Por esta razón, este trabajo se centra en la estimación del índice de mortalidad en los Estados Unidos a partir de los datos recogidos hasta el momento.


La tasa de mortalidad se puede calcular a partir de la cantidad de casos diagnosticados y la proporción qué representan los fallecidos. Al observar el gráfico se puede notar que el índice de mortalidad tiene una alta correlación con la cantidad de muertes. por esta razoón el problema se transforma en estimar el índice de letalidad suponiendo que conocemos la cantidad de casos y demás variables, pero no la cantidad de muertes.

Se calcula la matriz de correlación para verificar dicha relación. Los datos no muestran tal relación.
Se puede notar que los pares de variables *(Incident_Rate, Active)*, *(Deaths, Confirmed)*, *(Recovered, Confirmed)*, *(Total_Test_Results, Deaths)*, *(Total_Test_Results, Confirmed)* tienen una alta correlación.

```{r}
library(corrplot)
ggcorr(covid.data[,numeric_cols], label = T)
```
```{r}
barplot(covid.data$Case_Fatality_Ratio, col="darkblue")
```

Dividemos el cojunto de datos en *training* y *test*.


```{r}
set.seed(42)

trainIndex <- createDataPartition(c(covid.data$Province_State), p = .7,
                                  list = FALSE,
                                  times = 1)
training <- covid.data[ trainIndex,]
testing <- covid.data[-trainIndex,]
```


* Modelos lineales


```{r}

fit.lm <- lm(Case_Fatality_Ratio ~ ., data=training) 
summary(fit.lm)

# Diagnosis
par(mfrow=c(2,2))
plot(fit.lm)

```
* Modelo lineal con logaritmo
 
```{r}
fit.lm.log <- lm(log(Case_Fatality_Ratio+1) ~ . - Deaths, data=training) 
summary(fit.lm.log)

par(mfrow=c(2,2))
plot(fit.lm.log)

```

* Primer modelo GLM: todas las variables

```{r}

fit.glm.poisson.all <- glm(Deaths ~ . - Case_Fatality_Ratio, 
                       family = 'poisson', data=training, offset = log(Confirmed))
summary(fit.glm.poisson.all)

```

```{r}
exp(cbind(coef(fit.glm.poisson.all), confint(fit.glm.poisson.all)))
```
* GLM: seleccionando variables

```{r}
fit.glm.poisson <- glm(Deaths ~ . - Case_Fatality_Ratio - Active - Incident_Rate - 
                 Hospitalization_Rate - Testing_Rate, 
               family = 'poisson', data=training, offset = log(Confirmed))
summary(fit.glm.poisson)

```

Coeficientes

```{r}
exp(cbind(coef(fit.glm.poisson), confint(fit.glm.poisson)))
```
```{r}

plot(effect("Deaths", fit.glm.poisson), ci.style="band", rescale.axis=FALSE, multiline=TRUE, xlab="stars", ylab="rate", rug=FALSE, main="")
# a very clear relation
```





plot(effect("LabelAppeal", fit.poisson), ci.style="band", rescale.axis=FALSE, multiline=TRUE, xlab="label appeal", ylab="rate", rug=FALSE, main="")
# a very clear (but weaker) relation

plot(effect("LabelAppeal:STARS", fit.poisson), ci.style="band", rescale.axis=FALSE, multiline=TRUE, xlab="label appeal", ylab="rate", rug=FALSE, main="")
# a very clear relation

# All effects on target:
plot(allEffects(fit.poisson), rescale.axis=FALSE, multiline=TRUE, rug=FALSE, main="")







```{r}
fit.glm.qpoisson <- glm(Deaths ~ . - Case_Fatality_Ratio - Active - Incident_Rate - 
                 Hospitalization_Rate - Testing_Rate,
               family = 'quasipoisson', data=covid.data, offset = log(Confirmed))
summary(fit.glm.qpoisson)

```



## Including Plots




## Conclusiones


## Bibliografía

* https://apps.who.int/iris/bitstream/handle/10665/333857/WHO-2019-nCoV-Sci_Brief-Mortality-2020.1-spa.pdf